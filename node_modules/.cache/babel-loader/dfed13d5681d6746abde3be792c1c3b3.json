{"ast":null,"code":"import { get as atKey } from './json';\nimport { shallowObjDiff } from './diff';\n\nconst isDiffAtKey = (json1, json2, diff, key) => diff(atKey(json1, key), atKey(json2, key));\n\nexport const patch = (cy, json1, json2, diff, toJson, get, forEach) => {\n  cy.batch(() => {\n    // The shallow object diff() must defer to patchElements() as it must compare the\n    // elements as an unordered set.  A custom diff(), with Immutable for example,\n    // could just use an equality check (===).\n    if (diff === shallowObjDiff || isDiffAtKey(json1, json2, diff, 'elements')) {\n      patchElements(cy, atKey(json1, 'elements'), atKey(json2, 'elements'), toJson, get, forEach, diff);\n    }\n\n    if (isDiffAtKey(json1, json2, diff, 'stylesheet')) {\n      patchStyle(cy, atKey(json1, 'stylesheet'), atKey(json2, 'stylesheet'), toJson);\n    }\n\n    [// simple keys that can be patched directly (key same as fn name)\n    'zoom', 'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'pan', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autoungrabify', 'autolock', 'autounselectify'].forEach(key => {\n      if (isDiffAtKey(json1, json2, diff, key)) {\n        patchJson(cy, key, atKey(json1, key), atKey(json2, key), toJson);\n      }\n    });\n  });\n\n  if (isDiffAtKey(json1, json2, diff, 'layout')) {\n    patchLayout(cy, atKey(json1, 'layout'), atKey(json2, 'layout'), toJson);\n  }\n};\n\nconst patchJson = (cy, key, val1, val2, toJson) => {\n  cy[key](toJson(val2));\n};\n\nconst patchLayout = (cy, layout1, layout2, toJson) => {\n  const layoutOpts = toJson(layout2);\n\n  if (layoutOpts != null) {\n    cy.layout(layoutOpts).run();\n  }\n};\n\nconst patchStyle = (cy, style1, style2, toJson) => {\n  const style = cy.style();\n\n  if (style == null) {\n    return;\n  }\n\n  style.fromJson(toJson(style2)).update();\n};\n\nconst patchElements = (cy, eles1, eles2, toJson, get, forEach, diff) => {\n  const toAdd = [];\n  const toRm = cy.collection();\n  const toPatch = [];\n  const eles1Map = {};\n  const eles2Map = {};\n\n  const eles1HasId = id => eles1Map[id] != null;\n\n  const eles2HasId = id => eles2Map[id] != null;\n\n  const getEle1 = id => eles1Map[id];\n\n  const getId = ele => get(get(ele, 'data'), 'id');\n\n  forEach(eles2, ele2 => {\n    const id = getId(ele2);\n    eles2Map[id] = ele2;\n  });\n\n  if (eles1 != null) {\n    forEach(eles1, ele1 => {\n      const id = getId(ele1);\n      eles1Map[id] = ele1;\n\n      if (!eles2HasId(id)) {\n        toRm.merge(cy.getElementById(id));\n      }\n    });\n  }\n\n  forEach(eles2, ele2 => {\n    const id = getId(ele2);\n    const ele1 = getEle1(id);\n\n    if (eles1HasId(id)) {\n      toPatch.push({\n        ele1,\n        ele2\n      });\n    } else {\n      toAdd.push(toJson(ele2));\n    }\n  });\n\n  if (toRm.length > 0) {\n    cy.remove(toRm);\n  }\n\n  if (toAdd.length > 0) {\n    cy.add(toAdd);\n  }\n\n  toPatch.forEach(({\n    ele1,\n    ele2\n  }) => patchElement(cy, ele1, ele2, toJson, get, diff));\n};\n\nconst patchElement = (cy, ele1, ele2, toJson, get, diff) => {\n  const id = get(get(ele2, 'data'), 'id');\n  const cyEle = cy.getElementById(id);\n  const patch = {};\n  let jsonKeys = ['data', 'position', 'selected', 'selectable', 'locked', 'grabbable', 'classes'];\n  jsonKeys.forEach(key => {\n    const data2 = get(ele2, key);\n\n    if (diff(data2, get(ele1, key))) {\n      patch[key] = toJson(data2);\n    }\n  });\n  const scratch2 = get(ele2, 'scratch');\n\n  if (diff(scratch2, get(ele1, 'scratch'))) {\n    cyEle.scratch(toJson(scratch2));\n  }\n\n  if (Object.keys(patch).length > 0) {\n    cyEle.json(patch);\n  }\n};","map":{"version":3,"sources":["/home/john/research/ReSeSS/Visualization/microservice-diff-tool/src/Components/Cytoscape/patch.js"],"names":["get","atKey","shallowObjDiff","isDiffAtKey","json1","json2","diff","key","patch","cy","toJson","forEach","batch","patchElements","patchStyle","patchJson","patchLayout","val1","val2","layout1","layout2","layoutOpts","layout","run","style1","style2","style","fromJson","update","eles1","eles2","toAdd","toRm","collection","toPatch","eles1Map","eles2Map","eles1HasId","id","eles2HasId","getEle1","getId","ele","ele2","ele1","merge","getElementById","push","length","remove","add","patchElement","cyEle","jsonKeys","data2","scratch2","scratch","Object","keys","json"],"mappings":"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","sourcesContent":["import { get as atKey } from './json';\nimport { shallowObjDiff } from './diff';\n\nconst isDiffAtKey = (json1, json2, diff, key) =>\n  diff(atKey(json1, key), atKey(json2, key));\n\nexport const patch = (cy, json1, json2, diff, toJson, get, forEach) => {\n  cy.batch(() => {\n    // The shallow object diff() must defer to patchElements() as it must compare the\n    // elements as an unordered set.  A custom diff(), with Immutable for example,\n    // could just use an equality check (===).\n    if (\n      diff === shallowObjDiff ||\n      isDiffAtKey(json1, json2, diff, 'elements')\n    ) {\n      patchElements(\n        cy,\n        atKey(json1, 'elements'),\n        atKey(json2, 'elements'),\n        toJson,\n        get,\n        forEach,\n        diff\n      );\n    }\n\n    if (isDiffAtKey(json1, json2, diff, 'stylesheet')) {\n      patchStyle(\n        cy,\n        atKey(json1, 'stylesheet'),\n        atKey(json2, 'stylesheet'),\n        toJson\n      );\n    }\n\n    [\n      // simple keys that can be patched directly (key same as fn name)\n      'zoom',\n      'minZoom',\n      'maxZoom',\n      'zoomingEnabled',\n      'userZoomingEnabled',\n      'pan',\n      'panningEnabled',\n      'userPanningEnabled',\n      'boxSelectionEnabled',\n      'autoungrabify',\n      'autolock',\n      'autounselectify'\n    ].forEach(key => {\n      if (isDiffAtKey(json1, json2, diff, key)) {\n        patchJson(cy, key, atKey(json1, key), atKey(json2, key), toJson);\n      }\n    });\n  });\n\n  if (isDiffAtKey(json1, json2, diff, 'layout')) {\n    patchLayout(cy, atKey(json1, 'layout'), atKey(json2, 'layout'), toJson);\n  }\n};\n\nconst patchJson = (cy, key, val1, val2, toJson) => {\n  cy[key](toJson(val2));\n};\n\nconst patchLayout = (cy, layout1, layout2, toJson) => {\n  const layoutOpts = toJson(layout2);\n\n  if (layoutOpts != null) {\n    cy.layout(layoutOpts).run();\n  }\n};\n\nconst patchStyle = (cy, style1, style2, toJson) => {\n  const style = cy.style();\n\n  if (style == null) {\n    return;\n  }\n\n  style.fromJson(toJson(style2)).update();\n};\n\nconst patchElements = (cy, eles1, eles2, toJson, get, forEach, diff) => {\n  const toAdd = [];\n  const toRm = cy.collection();\n  const toPatch = [];\n  const eles1Map = {};\n  const eles2Map = {};\n  const eles1HasId = id => eles1Map[id] != null;\n  const eles2HasId = id => eles2Map[id] != null;\n  const getEle1 = id => eles1Map[id];\n  const getId = ele => get(get(ele, 'data'), 'id');\n\n  forEach(eles2, ele2 => {\n    const id = getId(ele2);\n\n    eles2Map[id] = ele2;\n  });\n\n  if (eles1 != null) {\n    forEach(eles1, ele1 => {\n      const id = getId(ele1);\n\n      eles1Map[id] = ele1;\n\n      if (!eles2HasId(id)) {\n        toRm.merge(cy.getElementById(id));\n      }\n    });\n  }\n\n  forEach(eles2, ele2 => {\n    const id = getId(ele2);\n    const ele1 = getEle1(id);\n\n    if (eles1HasId(id)) {\n      toPatch.push({ ele1, ele2 });\n    } else {\n      toAdd.push(toJson(ele2));\n    }\n  });\n\n  if (toRm.length > 0) {\n    cy.remove(toRm);\n  }\n\n  if (toAdd.length > 0) {\n    cy.add(toAdd);\n  }\n\n  toPatch.forEach(({ ele1, ele2 }) =>\n    patchElement(cy, ele1, ele2, toJson, get, diff)\n  );\n};\n\nconst patchElement = (cy, ele1, ele2, toJson, get, diff) => {\n  const id = get(get(ele2, 'data'), 'id');\n  const cyEle = cy.getElementById(id);\n  const patch = {};\n  let jsonKeys = [\n    'data',\n    'position',\n    'selected',\n    'selectable',\n    'locked',\n    'grabbable',\n    'classes'\n  ];\n\n  jsonKeys.forEach(key => {\n    const data2 = get(ele2, key);\n\n    if (diff(data2, get(ele1, key))) {\n      patch[key] = toJson(data2);\n    }\n  });\n\n  const scratch2 = get(ele2, 'scratch');\n  if (diff(scratch2, get(ele1, 'scratch'))) {\n    cyEle.scratch(toJson(scratch2));\n  }\n\n  if (Object.keys(patch).length > 0) {\n    cyEle.json(patch);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}